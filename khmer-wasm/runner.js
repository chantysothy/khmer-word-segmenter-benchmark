
import fs from 'fs';
import { addWord, segment, segmentBatch } from "./build/release.js";
import path from 'path';

// Usage: node runner.js --dict <dict_path> --freq <freq_path> --input <input_path> --output <output_path>

async function main() {
  const args = process.argv.slice(2);
  let dictPath = "";
  let freqPath = "";
  let inputPath = "";
  let outputPath = "";

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--dict' || args[i] === '-d') dictPath = args[++i];
    else if (args[i] === '--freq' || args[i] === '-f') freqPath = args[++i];
    else if (args[i] === '--input' || args[i] === '-i') inputPath = args[++i];
    else if (args[i] === '--output' || args[i] === '-o') outputPath = args[++i];
  }

  if (!inputPath) {
    console.error("Usage: node runner.js --dict <path> --freq <path> --input <path> [--output <path>]");
    console.error("Options:");
    console.error("  --output, -o <path>  Output file (optional, skip to benchmark only)");
    process.exit(1);
  }

  // 1. Load Dictionary and Frequencies (JS side)
  // We need to calculate costs and push them to WASM.
  // This might be slow (cross-boundary calls), but happens only once.

  console.log("Initializing WASM Segmenter...");
  const startLoad = performance.now();

  const words = new Set();
  if (fs.existsSync(dictPath)) {
    const content = fs.readFileSync(dictPath, 'utf-8');
    const lines = content.split(/\r?\n/);
    for (const line of lines) {
      const w = line.trim();
      if (!w) continue;
      // Filter (simplified matching C#/Node)
      if (w.includes("\u17D7")) continue;
      if (w.startsWith("\u17D2")) continue;
      if (w.includes("\u17D4") && w.length > 1) continue;
      words.add(w);
    }
  }

  let freqs = {};
  if (fs.existsSync(freqPath)) {
    try {
      freqs = JSON.parse(fs.readFileSync(freqPath, 'utf-8'));
    } catch (e) {
      console.error("Error loading freqs:", e);
    }
  }

  // Calculate costs
  let totalCount = 0;
  const DEFAULT_FREQ = 5.0;

  // First pass: sum
  for (const w of words) {
    totalCount += (freqs[w] || DEFAULT_FREQ);
  }
  if (totalCount <= 0) totalCount = 1;

  // Second pass: add to WASM
  // Batching? WASM exports addWord(string, float).
  // Calling it 20k times is fine.

  for (const w of words) {
    const count = freqs[w] || DEFAULT_FREQ;
    const cost = -Math.log10(count / totalCount);
    addWord(w, cost);
  }

  const loadTime = (performance.now() - startLoad) / 1000;
  console.log(`Model loaded in ${loadTime.toFixed(2)}s`);

  // 2. Process Input
  const inputContent = fs.readFileSync(inputPath, 'utf-8');
  // We filter to get the expected input lines for the JSON output
  const lines = inputContent.split(/\r?\n/).filter(line => line.trim().length > 0);

  console.log(`Processing ${lines.length} lines (Batch Mode)...`);

  const startProc = performance.now();

  // Use segmentBatch for high performance (minimized boundary crossing)
  const batchResult = segmentBatch(inputContent);
  const resultLines = batchResult.split("\n");

  // Write output only if outputPath is specified
  if (outputPath) {
    const outputStream = fs.createWriteStream(outputPath, { encoding: 'utf-8' });

    // Note: segmentBatch logic for skipping empty lines should match our filter above
    // for the workload generated by benchmark_battle.py (which has no empty lines inside).

    const len = Math.min(lines.length, resultLines.length);

    for (let i = 0; i < len; i++) {
      const line = lines[i];
      const segmentedStr = resultLines[i];
      // Split back to array for JSON format matching other runners
      // The WASM returns pipe separated
      const segments = segmentedStr.split("|");

      const record = {
        id: i,
        input: line,
        segments: segments
      };
      outputStream.write(JSON.stringify(record) + "\n");
    }

    outputStream.end();
  }

  const procTime = (performance.now() - startProc) / 1000;

  if (outputPath) {
    console.log(`Done. Saved to ${outputPath}`);
  }
  console.log(`Time taken: ${procTime.toFixed(2)}s`);
  console.log(`Speed: ${(lines.length / procTime).toFixed(2)} lines/sec`);
}


main().catch(err => {
  console.error(err);
  process.exit(1);
});
